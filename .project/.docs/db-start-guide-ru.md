Начните с того слоя, который хотите стабилизировать в первую очередь — оба пути возможны:

- **Если вы выбираете подход «сначала бэкэнд»** (Go + PostgreSQL + Redis):
1. Используйте файл `backend/guide.md` для создания каркаса проекта — запустите `go mod init`, установите зависимости и подключите папки Clean Architecture.
2. Заполните `assets/migrations/` (убедитесь, что файлы SQL соответствуют вашей схеме Postgres) и запустите их через `migrate` перед запуском сервера.  
  3. Запустите службу Go локально (fasthttp) и протестируйте конечные точки с помощью вашей коллекции Postman; в руководстве уже описаны промежуточное ПО JWT и маршруты работоспособности.  
  4. Как только бэкэнд будет готов, подключите к нему Hono для маршрутизации/аутентификации и настройте IAM на выдачу JWT.

- **Если вы предпочитаете сначала использовать Hono + Supabase**:  
  1. Следуйте инструкциям `hono/guide.md`, чтобы настроить проект Node, установить зависимости и настроить `.env` для режима Supabase.  
  2. Запустите `supabase db push` (или миграции), чтобы создать схему, затем запустите Hono (`tsx watch src/server.ts`) и используйте Postman, чтобы перейти по `/api/v1/auth/login`, `/health` и т. д.  
  3. После того, как Hono станет стабильным, подключите службу IAM для аутентификации и позже подключите бэкэнд Go, если необходимо.

Поскольку у вас уже есть Dokploy и Docker, выберите стек, который вам больше подходит; оба сервиса готовы к производству и могут быть протестированы с помощью Postman. Если вы хотите быстро увидеть поток данных, Hono + Supabase — это самый быстрый способ, а бэкэнд Go можно добавить позже, когда будут настроены потоки IAM/токен.

# Руководство по миграции бэкэнда Supabase в Go

## Обзор
В этом руководстве описано, что необходимо экспортировать из Supabase (схема, аутентификация, хранилище, политики), чтобы бэкэнд Go мог запуститься локально и быть развернут без проблем с PostgreSQL + Redis. Рассматривайте Supabase как прототипную плоскость данных: после проверки структуры скопируйте схему/данные и переключитесь на бэкэнд Go без потери готовности.

## Шаг 1 — Экспорт основной схемы
1. Запустите `supabase db dump --schema public > schema.sql` (или используйте редактор SQL, чтобы загрузить определение каждой таблицы).
2. Сохраните схему в `backend/assets/migrations/` с понятными для человека именами (`001_users.sql` и т. д.).
3. Сохраните расширения, специфичные для Supabase (например, `uuid-ossp`), но оберните их с помощью `CREATE EXTENSION IF NOT EXISTS`.
4. Сохраните индексы, ограничения, триггеры и политики в тех же файлах SQL.

## Шаг 2 — Экспорт справочных данных
1. Используйте `supabase db dump --data-only --tables=profiles,tasks` для захвата исходных данных.
2. Преобразуйте временные метки в UTC и замените секретные данные ролей службы Supabase переменными окружения.
3. Добавьте эти данные в `backend/assets/fixtures/` с инструкциями для `psql -f`.

## Шаг 3 — Сбор данных аутентификации и IAM
1. Экспортируйте таблицы аутентификации Supabase (`auth.users`, `auth.refresh_tokens`), чтобы понять сопоставление идентификаторов.
2. Задокументируйте используемые заявки JWT (например, `user_id`, `app_metadata.role`), чтобы промежуточное ПО Go могло их реплицировать.
3. При использовании политик Supabase зафиксируйте логику, чтобы в Postgres, управляемом Go, существовали эквивалентные представления SQL или правила безопасности на уровне строк.

## Шаг 4 – Определение ресурсов хранения
1. Если вы используете хранилище Supabase, запишите названия корзин и метаданные файлов.
2. Запланируйте эквивалентное хранилище (MinIO/S3) и предоставьте подписанные URL-адреса через бэкэнд Go.

## Шаг 5 – Мониторинг и метрики
1. Supabase предоставляет статистику/метрики запросов. Запишите пороговые значения (медленный запрос > 1 с) и добавьте их в конфигурацию мониторинга Go (`assets/docs/monitoring.md`).
2. Отразите ожидания Supabase по работоспособности через конечные точки `/health` и `/ready`.

## Шаг 6 – Контрольный список миграции
1. Запустите миграции с помощью `scripts/migrate.sh` (или `golang-migrate`).
2. Загрузите фикстуры с помощью `psql -f assets/fixtures/*.sql`.
3. Убедитесь, что заявки JWT и хранилище сеансов (Redis) соответствуют поведению Supabase.
4. Используйте коллекцию Postman для обращения к конечным точкам; сравните результаты с ответами Supabase.
5. После получения зеленого сигнала переключите фронтенд/шлюз API на бэкенд Go.

## Примечания
- Рассматривайте Supabase как среду быстрого прототипирования. После окончательной доработки схемы/данных оставайтесь в бэкенде Go для полного контроля (буферизация Bolt, сессии Redis, настраиваемое промежуточное ПО).
- Документируйте любую специфическую для Supabase логику в `backend/assets/docs/supabase-fallback.md`, чтобы будущие команды знали, что было перенесено.

# Как работать с одной БД

Supabase — это надстройка над PostgreSQL, то есть она разворачивает обычную Postgres-базу. Ты получаешь:

- **Прямой доступ к той же базе** через Supabase Studio (веб-интерфейс) и через любой PG-клиент (pgAdmin, DBeaver, psql и т.д.).
- **Админка и мониторинг** в Supabase полезны для быстрого прототипирования, но любые таблицы/данные доступны по стандартному `postgres://`-URI, который можно дать своему Go-бэкенду.
- **Безопасность**: оставляй IAM/Row Level Security в Supabase включёнными, а бэкенд подключай используя секретный сервис-роль или роль с минимальными правами.
- **Одновременно администрировать** — тоже можно: ты можешь править схемы, политики, функции из Supabase, а в pgAdmin смотреть структуру/запросы/логи.

Просто держи в голове миграционный процесс: когда перейдёшь на собственный Go + Postgres, экспортируй SQL из Supabase (см. `supabase-migrate.md`) и применяй на новой базе, чтобы ничего не потерять.

# Чем похожи Postgre и MySQL. Как редактировать в IDE

PostgreSQL ведет себя очень похоже на MySQL, когда вам нужны дампы и автономное редактирование:

- **Дампы схемы + данных**: `pg_dump` может экспортировать все в один файл SQL (`pg_dump --schema-only`, `--data-only` или оба). Вы можете редактировать этот файл в любой IDE, как дамп MySQL. Supabase позволяет загружать эти дампы через CLI (`supabase db dump`) или из редактора SQL. Вы также можете запустить `pg_dump` напрямую по строке подключения, предоставленной Supabase.

- **Несколько файлов**: Вам не нужно хранить десятки файлов; ваш стек миграции (golang-migrate, Flyway и т. д.) работает с версионными файлами SQL. Каждая миграция, как правило, является аддитивной (одна миграция на одно изменение), поэтому вы можете безопасно отслеживать историю. Если вы предпочитаете один файл, вы можете объединить миграции перед их применением (или поддерживать `schema.sql`, который перегенерируется из этих миграций).

- **Защита данных**:
  - Всегда делайте дамп (`pg_dump --format=custom`) перед запуском миграций, чтобы вы могли быстро восстановить данные.
  - По возможности запускайте миграции внутри транзакций (`BEGIN; …; COMMIT;`). Postgres поддерживает транзакционный DDL для большинства операций.
  - Используйте функции резервного копирования/восстановления Supabase для производственных данных.
  - Сохраняйте рабочий процесс `supabase-migrate.md`: экспортируйте схему, сохраните ее в `assets/migrations` и примените через `scripts/migrate.sh`. Таким образом, вы сможете повторно запустить миграции для любого экземпляра Postgres (локального, Supabase, pgAdmin).

  - **Редактирование**: Вы можете редактировать выгруженный SQL в своей IDE, а затем применять его с помощью `psql` или `golang-migrate`. Для специальных настроек pgAdmin или Supabase Studio предоставляют SQL-редакторы с историей версий.

Ключ к успеху — включить резервное копирование и миграцию в свой рабочий процесс. С помощью `supabase-migrate.md` у вас уже есть план: хранить дампы под контролем версий, документировать существующие таблицы/данные и всегда тестировать миграции на копии, прежде чем приступать к производству.

# Руководство по PostgreSQL 101 для бэкэнда

## Почему PostgreSQL?
- Открытая, проверенная временем реляционная база данных.
- Поддерживает JSONB, транзакции, наблюдаемость и надежные инструменты.
- Нативная совместимость с Supabase и Go (pgx, pgxpool).

## Основы настройки
1. **Установите локально**
   ```bash
   sudo apt install postgresql postgresql-contrib
   ```
2. **Запустить сервер и создать пользователя**
   ```bash
   sudo -u postgres createuser --interactive
   sudo -u postgres createdb backend_db
   psql -c «ALTER ROLE you SET client_encoding TO „utf8“;»
   ```
3. **Подключитесь с помощью pgAdmin/psql**
```bash
   psql postgresql://user:pass@localhost:5432/backend_db
   ````**Используйте `.pgpass`**, чтобы избежать ввода пароля в интерактивном режиме.

## Управление схемой
1. **Файлы миграции**
   - Поместите SQL в `assets/migrations/`, используя последовательные префиксы (`001_users.sql`).
   - Предпочтительно использовать `CREATE TABLE IF NOT EXISTS`, `ALTER TABLE ... IF EXISTS`, `CREATE EXTENSION IF NOT EXISTS`.
2. **Запуск миграций**
   ```bash
   migrate -path assets/migrations -database «${DATABASE_URL}» up
   ```
3. **Откат**
   ```bash
   migrate -path assets/migrations -database «${DATABASE_URL}» down
   ```
4. **Фикстуры**
   - Сохраните исходные данные в `assets/fixtures/`.
   - Загрузите с помощью `psql -f assets/fixtures/users.sql`.

## Резервное копирование и восстановление
1. **Дамп схемы/данных**
   ```bash
   pg_dump --format=custom --file=backups/db.dump «${DATABASE_URL}»
   ```
2. **Восстановление**
   ```bash
   pg_restore --clean --no-owner --dbname=«${DATABASE_URL}» backups/db.dump
   ```

3. **Экспорт Supabase**
   Supabase CLI: `supabase db dump --schema public --file=schema.sql`

## Шаблоны доступа к данным
1. **Использование транзакций в Go**
```go
   pgx.BeginFunc(ctx, pool, func(tx pgx.Tx) error {
       // операции
   })
   ```
2. **Подготовленные запросы**
   - `tx.Exec(ctx, «INSERT ...», args...)`
3. **JSONB**
   - Храните метаданные в формате JSONB, выполняйте запросы с помощью операторов `->`.

## Мониторинг
1. **pg_stat_statements**: отслеживание медленных запросов.
2. **Расширения**: `pgstattuple`, `pg_stat_io`.
3. **Оповещения**: настройте на `pg_stat_activity` длительные запросы, количество подключений.

## Supabase и PostgreSQL
1. Supabase работает на базе PostgreSQL; вы можете подключиться напрямую к той же базе данных из pgAdmin или вашего бэкэнда Go.
2. Экспортируйте схему/дампы из Supabase (`supabase db dump`) и сохраните в `assets/migrations`.
3. Когда будете готовы покинуть Supabase, запустите миграции на вашем новом экземпляре PostgreSQL и настройте бэкэнд на ту же схему.

## Советы по безопасности
1. Всегда делайте резервную копию перед миграцией.
2. Тестируйте миграции на стадии подготовки перед запуском в производство.
3. Используйте `pg_isready` для проверки доступности во время развертывания.
4. Храните `DATABASE_URL` в `.env` и никогда не фиксируйте секретные данные.